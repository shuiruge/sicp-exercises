; 1.5 exe
(define (p) (p))
(define (test x y)
  (if (= x 0)
      0
      y))
(test 0 (p))
;; returning an endless

;; Explain:
;; Because of applicative order, that is "the innermost runs the first", when evaluate `(test 0 (p))`, the operand `(p)` will be evaluated before evaluating `test`. However, `p` is defined as a endless loop.
;; Contrarily, for a normal order interpreter, judegement is taken first. Thus no opportunity would `p` be run.
;; Really???

;; Another way of doing so is:
(define (new-p)
  (define (env) 73))
(define (new-test x y)
  (if (= x 0)
      0
      y))
(new-test 0 (new-p))
(env)


; 1.6 exe.
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
	(else else-clause)))
(define (new-sqrt-iter guess x)
  (new-if (good-enough? guess x)
	  guess
	  (new-sqrt-iter (improve guess x)
		     x)))
;; wherein:
(define (good-enough? guess x)
  (< (distance (* guess guess)
	       x)
     0.001))
(define (distance x y)
  (abs (- x y)))
(define (improve guess x)
  (average guess (/ x guess)))
(define (average x y)
  (/ (+ x y) 2))
;; as comparision
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
		 x)))

;; run in bigloo
(new-sqrt-iter 1 2)
;; returning ERROR
;;     *** ERROR:bigloo:
;;     `segmentation violation' exception -- raised
;;      1. improve, stdin@607
;;      2. new-sqrt-iter, stdin@235
;;      ......
;;      10. new-sqrt-iter, stdin@235

;; Explain:
;; When calling `new-if` in the first level of recursion of `new-sqrt-iter`, before evaluating it, its operand shall be evaluated first (That is, "the innermost runs the first". C.f. section 1.1.5), **even before evaluating `cond`!** The same will happen in the second level of recursion, wherein the `cond` will not be evaluated too. And so on, and so on. Without making a judgement, never will this recursion stop. This maybe how things go wrong.
;; Contrarily, `sqrt-iter` runs well, since the judgement is taken **before** calling the recursion.

;; Conclusion:
;; Bug is hard to be avoided!


; 1.7 exe.
(define (new-good-enough? guess x)
  (< (relative-distance guess
			(improve guess x))
     0.001))
(define (relative-distance x y)
  (/ (distance x y)
     (abs x)))
(define (nnew-sqrt-iter guess x)
  (if (new-good-enough? guess x)
      guess
      (nnew-sqrt-iter (improve guess x)
		      x)))
(nnew-sqrt-iter 1 2)
(sqrt-iter 1 2)
;; no improvement?


; 1.8 exe.
(define (improve-cubic guess x)
  (/ (+ (/ x (* guess guess))
	(* 2 guess))
     3))
(define (good-enough?-cubic guess x)
  (< (distance (* guess guess guess)
	       x)
     0.001))
(define (sqrt-iter-cubic guess x)
  (if (good-enough?-cubic guess x)
      guess
      (sqrt-iter-cubic (improve-cubic guess x)
		       x)))
(sqrt-iter-cubic 1 8)


; 1.9 exe.
;; For the first:
;; 
;; (+ 4 5)
;; (inc (+ (dec 4) 5))
;; (inc (+ 3 5))
;; (inc (inc (+ (dec 3) 5)))
;; (inc (inc (+ 2 5)))
;; (inc (inc (inc (inc (+ (dec 2) 5)))))
;; (inc (inc (inc (inc (+ 1 5)))))
;; (inc (inc (inc (inc (inc (+ (dec 1) 5))))))
;; (inc (inc (inc (inc (inc (+ 0 5))))))
;; (inc (inc (inc (inc (inc 5)))))
;; (inc (inc (inc 6)))
;; (inc (inc 7))
;; (inc 8)
;; 9
;; 
;; which is manifestly recursive.
;; And for the second:
;; 
;; (+ 4 5)
;; (+ (dec 4) (inc 5))
;; (+ 3 6)
;; (+ (dec 3) (inc 6))
;; (+ 2 7)
;; (+ (dec 2) (inc 7))
;; (+ 1 8)
;; (+ (dec 1) (inc 8))
;; (+ 0 9)
;; 9
;; 
;; which is manifestly iterative.

; 1.10 exe.
; Q1-1:
;; (A 1 2)
;; (A 0
;;   (A 1 1))
;; (A 0 2)
;; 4 = 2^2
;; ......
;; (A 1 10) returns 2^10
;; 
;; Q1-2:
;; (A 2 4)
;; (A 1
;;   (A 2 3))
;; (A 1
;;   (A 1 
;;     (A 2 2)))
;; (A 1
;;   (A 1 
;;     (A 1 
;;       (A 2 1))))
;; (A 1
;;   (A 1 
;;     (A 1 2)))
;; (A 1
;;   (A 1 2^2))
;; (A 1 2^2^2)
;; 2^2^2^2
;;
;; Q1-3:
;; (A 3 3)
;; (A 2
;;   (A 3 2))
;; (A 2
;;   (A 2
;;     (A 3 1)))
;; (A 2
;;   (A 2 2))
;; (A 2 2^2)
;; (A 2 4)
;; 2^2^2^2
;;
;; Q2:
;; f(n) = 2 * n
;; g(n) = 2 ^ n
;; h(n) = 2 ^ ... ^ 2, with n 2s.





