; 1.5
(define (p) (p))
(define (test x y)
  (if (= x 0)
      0
      y))
(test 0 (p))
;; returning an endless

;; Explain:
;; Because of applicative order, that is "the innermost runs the first", when evaluate `(test 0 (p))`, the operand `(p)` will be evaluated before evaluating `test`. However, `p` is defined as a endless loop.
;; Contrarily, for a normal order interpreter, judegement is taken first. Thus no opportunity would `p` be run.
;; Really???

;; Another way of doing so is:
(define (new-p)
  (define (env) 73))
(define (new-test x y)
  (if (= x 0)
      0
      y))
(new-test 0 (new-p))
(env)


; 1.6
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
	(else else-clause)))
(define (new-sqrt-iter guess x)
  (new-if (good-enough? guess x)
	  guess
	  (new-sqrt-iter (improve guess x)
		     x)))
;; wherein:
(define (good-enough? guess x)
  (< (distance (* guess guess)
	       x)
     0.001))
(define (distance x y)
  (abs (- x y)))
(define (improve guess x)
  (average guess (/ x guess)))
(define (average x y)
  (/ (+ x y) 2))
;; as comparision
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
		 x)))

;; run in bigloo
(new-sqrt-iter 1 2)
;; returning ERROR
;;     *** ERROR:bigloo:
;;     `segmentation violation' exception -- raised
;;      1. improve, stdin@607
;;      2. new-sqrt-iter, stdin@235
;;      ......
;;      10. new-sqrt-iter, stdin@235

;; Explain:
;; When calling `new-if` in the first level of recursion of `new-sqrt-iter`, before evaluating it, its operand shall be evaluated first (That is, "the innermost runs the first". C.f. section 1.1.5), **even before evaluating `cond`!** The same will happen in the second level of recursion, wherein the `cond` will not be evaluated too. And so on, and so on. Without making a judgement, never will this recursion stop. This maybe how things go wrong.
;; Contrarily, `sqrt-iter` runs well, since the judgement is taken **before** calling the recursion.

;; Conclusion:
;; Bug is hard to be avoided!


; 1.7
(define (new-good-enough? guess x)
  (< (relative-distance guess
			(improve guess x))
     0.001))
(define (relative-distance x y)
  (/ (distance x y)
     (abs x)))
(define (nnew-sqrt-iter guess x)
  (if (new-good-enough? guess x)
      guess
      (nnew-sqrt-iter (improve guess x)
		      x)))
(nnew-sqrt-iter 1 2)
(sqrt-iter 1 2)
;; no improvement?


; 1.8
(define (improve-cubic guess x)
  (/ (+ (/ x (* guess guess))
	(* 2 guess))
     3))
(define (good-enough?-cubic guess x)
  (< (distance (* guess guess guess)
	       x)
     0.001))
(define (sqrt-iter-cubic guess x)
  (if (good-enough?-cubic guess x)
      guess
      (sqrt-iter-cubic (improve-cubic guess x)
		       x)))
(sqrt-iter-cubic 1 8)


; 1.9
;; For the first:
;; 
;; (+ 4 5)
;; (inc (+ (dec 4) 5))
;; (inc (+ 3 5))
;; (inc (inc (+ (dec 3) 5)))
;; (inc (inc (+ 2 5)))
;; (inc (inc (inc (inc (+ (dec 2) 5)))))
;; (inc (inc (inc (inc (+ 1 5)))))
;; (inc (inc (inc (inc (inc (+ (dec 1) 5))))))
;; (inc (inc (inc (inc (inc (+ 0 5))))))
;; (inc (inc (inc (inc (inc 5)))))
;; (inc (inc (inc 6)))
;; (inc (inc 7))
;; (inc 8)
;; 9
;; 
;; which is manifestly recursive.
;; And for the second:
;; 
;; (+ 4 5)
;; (+ (dec 4) (inc 5))
;; (+ 3 6)
;; (+ (dec 3) (inc 6))
;; (+ 2 7)
;; (+ (dec 2) (inc 7))
;; (+ 1 8)
;; (+ (dec 1) (inc 8))
;; (+ 0 9)
;; 9
;; 
;; which is manifestly iterative.

; 1.10
; Q1-1:
;; (A 1 2)
;; (A 0
;;   (A 1 1))
;; (A 0 2)
;; 4 = 2^2
;; ......
;; (A 1 10) returns 2^10
;; 
;; Q1-2:
;; (A 2 4)
;; (A 1
;;   (A 2 3))
;; (A 1
;;   (A 1 
;;     (A 2 2)))
;; (A 1
;;   (A 1 
;;     (A 1 
;;       (A 2 1))))
;; (A 1
;;   (A 1 
;;     (A 1 2)))
;; (A 1
;;   (A 1 2^2))
;; (A 1 2^2^2)
;; 2^2^2^2
;;
;; Q1-3:
;; (A 3 3)
;; (A 2
;;   (A 3 2))
;; (A 2
;;   (A 2
;;     (A 3 1)))
;; (A 2
;;   (A 2 2))
;; (A 2 2^2)
;; (A 2 4)
;; 2^2^2^2
;;
;; Q2:
;; f(n) = 2 * n
;; g(n) = 2 ^ n
;; h(n) = 2 ^ ... ^ 2, with n 2s.

; 1.11
;; tree-recursion
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
         (* 2
            (f (- n 2)))
         (* 3
            (f (- n 3))))))

;; iteration
(define (f n)
  (if (< n 3)
      n
      (f-iter n 3 2 1 0)))
(define (f-iter n count f-count-1 f-count-2 f-count-3)
  (if (= (- count 1) n)
        f-count-1
        (f-iter n
                (+ count 1)
                (+ f-count-1
                   (* 2 f-count-2)
                   (* 3 f-count-3))
                f-count-1
                f-count-2)))

; 1.12
(define (pascal-triangle row column)
  (cond ((> column row) 'empty)
        ((or (= column 1)
             (= column row))
          1)
        (else (if (= row 1)
                  1
                  (+ (pascal-triangle (- row 1)
                                      (- column 1))
                     (pascal-triangle (- row 1)
                                      column))))))

; 1.13
;; A math problem???

; 1.14
;; What is a cent???

; 1.15
;; Q-a:
;; log_3(12.5 / 0.1)
;; Q-b:
;; Theta of a and Theta of log(a).

; 1.16
define (fast-expt b n)
  (fast-expt-iter b n 1))
(define (fast-expt-iter b n a)
  (if (= n 0)
      a
      (if (even? n)
          (fast-expt-iter (* b b)
                          (/ n 2)
                          a)
          (fast-expt-iter b
                          (- n 1)
                          (* a b)))))

; 1.17
(define (fast-multiply n b)
  (fast-multiply-iter n b 0))
(define (fast-multiply-iter n b product)
  (if (= n 0)
      product
      (if (even? n)
          (fast-multiply-iter (halve n) (double b) product)
          (fast-multiply-iter (- n 1) b (+ product b)))))
;; and for self-consistency:
(define (halve a)
  (/ a 2))
(define (double a)
  (* a 2))

; 1.18
;; Isn't this 1.17 again???

; 1.19
;; (b p + a q) q + (b q + a q + a p) (p + q)
;; = b p q + a q q + b p q + a p q + a p p + b q q + a q q + a p q
;; = b (2 p q + q q) + a (2 q q + 2 p q + p p)
;; = b (2 p q + q q) + a (2 p q + q q) + a (q q + p p)
;; => q -> 2 p q + q q; p -> q q + p p
;; thus:
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* q q) (* p p))	      ; compute p'
                   (+ (* 2 p q) (* q q))      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
;; by comparison with the most original version of `fib`, this does be amazingly fast.